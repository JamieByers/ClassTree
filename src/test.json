[
  {
    "fileName": "/Users/jamiebyers/Documents/Code/Projects/ClassTree/src/lexer.rs",
    "fileType": "rust",
    "fileNo": 1,
    "lines": [
      [1, "use core::panic;"],
      [2, "use std::collections::HashMap;"],
      [3, "use crate::structs::{FileData, Token, TokenisedFileData};"],
      [4, ""],
      [5, ""],
      [6, "pub struct Lexer {"],
      [7, "    pos: usize,"],
      [8, "    current_char: char,"],
      [9, "    current_line: String,"],
      [10, "    files: Vec<FileData>,"],
      [11, "}"],
      [12, ""],
      [13, ""],
      [14, "impl Lexer {"],
      [15, "    pub fn new(files: Vec<FileData>) -> Self {"],
      [16, "        Lexer {"],
      [17, "            pos: 0,"],
      [18, "            current_char: '\\0',"],
      [19, "            current_line: String::new(),"],
      [20, "            files,"],
      [21, "        }"],
      [22, "    }"],
      [23, ""],
      [24, "    pub fn advance(&mut self) -> char {"],
      [25, "        // println!(\"Current token at advance \\\"{}\\\", '{}', {}, {}\", self.current_char, self.current_line, self.pos, self.current_line.len());"],
      [26, "        if self.pos <= self.current_line.len() {"],
      [27, "            self.pos += 1;"],
      [28, "            self.current_char = self.current_line[self.pos..]"],
      [29, "                .chars()"],
      [30, "                .next()"],
      [31, "                .unwrap_or('\\0');"],
      [32, ""],
      [33, "            self.current_char"],
      [34, "        } else {"],
      [35, "            '\\0'"],
      [36, "        }"],
      [37, ""],
      [38, "    }"],
      [39, ""],
      [40, "    pub fn lex(&mut self) -> Vec<TokenisedFileData> {"],
      [41, "        let mut tokenised_files = Vec::new();"],
      [42, ""],
      [43, "        for file in self.files.clone() {"],
      [44, "            let lines = file.lines.clone();"],
      [45, "            let mut new_lines = HashMap::new();"],
      [46, ""],
      [47, "            for line in lines {"],
      [48, "                self.current_line = line.1;"],
      [49, "                self.pos = 0;"],
      [50, "                self.current_char = self.current_line.chars().nth(self.pos).unwrap_or('\\0');"],
      [51, ""],
      [52, "                let line_tokens = self.handle_line();"],
      [53, "                // println!(\"line tokens: {:?}, {}\", line_tokens, self.current_line);"],
      [54, ""],
      [55, "                new_lines.insert(line.0, line_tokens);"],
      [56, "            }"],
      [57, ""],
      [58, "            let file_no = file.file_no;"],
      [59, "            let file_type = file.file_type.clone();"],
      [60, "            let filepath = file.filepath.clone();"],
      [61, ""],
      [62, "            let new_file = TokenisedFileData {"],
      [63, "                file_no,"],
      [64, "                file_type,"],
      [65, "                filepath,"],
      [66, "                lines: new_lines,"],
      [67, ""],
      [68, "            };"],
      [69, ""],
      [70, "            tokenised_files.push(new_file);"],
      [71, "        }"],
      [72, ""],
      [73, "        return tokenised_files"],
      [74, ""],
      [75, "    }"],
      [76, ""],
      [77, "    pub fn handle_line(&mut self) -> Vec<Token> {"],
      [78, "        let mut tokens = Vec::new();"],
      [79, "        while self.current_char != '\\0' {"],
      [80, "            let token = self.next_token();"],
      [81, "            tokens.push(token);"],
      [82, "        }"],
      [83, ""],
      [84, "        return tokens"],
      [85, "    }"],
      [86, ""],
      [87, ""],
      [88, "    pub fn next_token(&mut self) -> Token {"],
      [89, "        while self.current_char.is_whitespace() && self.current_char != '\\0' {"],
      [90, "            self.advance();"],
      [91, "        }"],
      [92, ""],
      [93, ""],
      [94, "        let token = match self.current_char {"],
      [95, "            'a'..='z' | 'A'..='Z' => {"],
      [96, "                let identifier = self.handle_indentifier();"],
      [97, "                let identifier_token = self.match_identifier(identifier);"],
      [98, "                // don't advance again in these functions"],
      [99, ""],
      [100, "                identifier_token"],
      [101, "            },"],
      [102, ""],
      [103, "            '0'..='9' => self.handle_number(),"],
      [104, ""],
      [105, "            ',' | ':' | ';' | '=' => self.handle_punctuation(),"],
      [106, ""],
      [107, "            '(' | ')' => self.handle_parenthesis(),"],
      [108, ""],
      [109, "            '{' | '}' => self.handle_braces(),"],
      [110, ""],
      [111, "            '\"' | '\\'' => self.handle_string(),"],
      [112, ""],
      [113, "            '\\0' => Token::Eof,"],
      [114, ""],
      [115, "            _ => {"],
      [116, "                let c = self.current_char;"],
      [117, "                self.advance();"],
      [118, "                return Token::Other(c)"],
      [119, "            },"],
      [120, "        };"],
      [121, ""],
      [122, "        return token"],
      [123, "    }"],
      [124, ""],
      [125, "    fn handle_punctuation(&mut self) -> Token {"],
      [126, "        let c = match self.current_char {"],
      [127, "            ',' => Token::Comma,"],
      [128, "            ':' => Token::BlockOpen(':'),"],
      [129, "            ';' => Token::Semicolon,"],
      [130, "            '=' => Token::Equals,"],
      [131, "            _ => panic!(\"Cannot tokenise punctuation\")"],
      [132, "        };"],
      [133, ""],
      [134, "        self.advance();"],
      [135, "        return c"],
      [136, "    }"],
      [137, ""],
      [138, "    fn handle_indentifier(&mut self) -> String {"],
      [139, "        let mut identifier: String = String::new();"],
      [140, "        while !self.current_char.is_whitespace() && (self.current_char.is_alphabetic() || self.current_char == '_') {"],
      [141, "            identifier.push(self.current_char);"],
      [142, "            self.advance();"],
      [143, "        }"],
      [144, ""],
      [145, "        identifier"],
      [146, "    }"],
      [147, ""],
      [148, "    fn match_identifier(&mut self, identifier: String) -> Token {"],
      [149, "        let object_keywords: Vec<&str> = vec!["],
      [150, "            \"Class\","],
      [151, "            \"enum\","],
      [152, "            \"interface\","],
      [153, "            \"class\","],
      [154, "            \"defmodule\","],
      [155, "            \"defstruct\","],
      [156, "            \"enum\","],
      [157, "            \"impl\","],
      [158, "            \"interface\","],
      [159, "            \"module\","],
      [160, "            \"object\","],
      [161, "            \"protocol\","],
      [162, "            \"record\","],
      [163, "            \"struct\","],
      [164, "            \"table\","],
      [165, "            \"trait\","],
      [166, "            \"type\","],
      [167, "            \"union\","],
      [168, "        ];"],
      [169, ""],
      [170, "        if object_keywords.contains(&identifier.as_str()) {"],
      [171, "            return Token::ObjectDeclaration"],
      [172, "        } else {"],
      [173, "            return Token::Identifier(identifier);"],
      [174, "        }"],
      [175, "    }"],
      [176, ""],
      [177, "    fn handle_number(&mut self) -> Token {"],
      [178, "        let mut num = String::new();"],
      [179, ""],
      [180, "        while self.current_char.is_numeric() {"],
      [181, "            num.push(self.current_char);"],
      [182, "            self.advance();"],
      [183, "        }"],
      [184, ""],
      [185, "        Token::Number(num)"],
      [186, "    }"],
      [187, ""],
      [188, ""],
      [189, "    // could be possible issues with strings within strings: \" \\\" hello world! \\\" \""],
      [190, "    // --- ADDRESS LATER BEFORE MOVING ONTO PARSER"],
      [191, "    fn handle_string(&mut self) -> Token {"],
      [192, "        let opening_string = self.current_char;"],
      [193, "        self.advance(); // skip \""],
      [194, ""],
      [195, "        let mut string = String::new();"],
      [196, "        while self.current_char != opening_string {"],
      [197, "            string.push(self.current_char);"],
      [198, "            self.advance();"],
      [199, "        }"],
      [200, ""],
      [201, "        self.advance(); // skip \""],
      [202, "        Token::StringLiteral(string)"],
      [203, "    }"],
      [204, ""],
      [205, ""],
      [206, "    fn handle_parenthesis(&mut self) -> Token {"],
      [207, "        let paren = self.current_char;"],
      [208, "        self.advance(); // skip '(' / ')'"],
      [209, "        Token::Parenthesis(paren)"],
      [210, "    }"],
      [211, ""],
      [212, "    fn handle_braces(&mut self) -> Token {"],
      [213, "        let b = match self.current_char {"],
      [214, "            '{' => Token::BlockOpen('{'),"],
      [215, "            '}' => Token::BlockClose,"],
      [216, "            _ => panic!(\"Not braces\")"],
      [217, "        };"],
      [218, ""],
      [219, "        self.advance();"],
      [220, "        return b"],
      [221, "    }"],
      [222, "}"]
    ]
  },
  {
    "fileName": "/Users/jamiebyers/Documents/Code/Projects/ClassTree/src/main.rs",
    "fileType": "rust",
    "fileNo": 2,
    "lines": [
      [1, "use std::{collections::HashMap, io::{self, Read}};"],
      [2, "use crate::lexer::Lexer;"],
      [3, "use crate::parser::Parser;"],
      [4, "use crate::structs::FileData;"],
      [5, "use serde_json;"],
      [6, ""],
      [7, "pub mod lexer;"],
      [8, "pub mod parser;"],
      [9, "pub mod structs;"],
      [10, ""],
      [11, ""],
      [12, "fn main() {"],
      [13, "    let mut buffer = String::new();"],
      [14, "    let _ = io::stdin().read_to_string(&mut buffer);"],
      [15, ""],
      [16, "    let json: serde_json::Value = serde_json::from_str(&buffer).unwrap();"],
      [17, "    let all_files = get_all_files(json);"],
      [18, ""],
      [19, "    let mut lexer = Lexer::new(all_files);"],
      [20, ""],
      [21, "    let tkls = lexer.lex();"],
      [22, ""],
      [23, "    let mut parser = Parser::new(tkls);"],
      [24, ""],
      [25, "    let _possible_objects = parser.possible_objects();"],
      [26, ""],
      [27, "}"],
      [28, ""],
      [29, "fn get_all_files(json: serde_json::Value) -> Vec<FileData> {"],
      [30, "    let mut all_files: Vec<FileData> = Vec::new();"],
      [31, ""],
      [32, "    if let serde_json::Value::Array(files) = &json {"],
      [33, "        for file in files {"],
      [34, ""],
      [35, "            let file_no = file[\"fileNo\"].as_i64().unwrap() as i16;"],
      [36, "            let filepath = file[\"fileName\"].as_str().unwrap().to_string();"],
      [37, "            let file_type = file[\"fileType\"].as_str().unwrap().to_string();"],
      [38, "            let mut lines_map = HashMap::new();"],
      [39, ""],
      [40, "            if let serde_json::Value::Array(lines) = &file[\"lines\"] {"],
      [41, "                for line in lines {"],
      [42, "                    let line_number: i64 = line[0].as_i64().unwrap();"],
      [43, "                    let line_body: String = line[1].as_str().unwrap().to_string();"],
      [44, "                    lines_map.insert(line_number, line_body);"],
      [45, "                }"],
      [46, "            }"],
      [47, ""],
      [48, "            let file_data = FileData {"],
      [49, "                file_no,"],
      [50, "                filepath,"],
      [51, "                file_type,"],
      [52, "                lines: lines_map,"],
      [53, "            };"],
      [54, ""],
      [55, "            all_files.push(file_data);"],
      [56, "        }"],
      [57, "    }"],
      [58, ""],
      [59, "    return all_files;"],
      [60, "}"],
      [61, ""]
    ]
  },
  {
    "fileName": "/Users/jamiebyers/Documents/Code/Projects/ClassTree/src/parser.rs",
    "fileType": "rust",
    "fileNo": 3,
    "lines": [
      [1, "use crate::structs::{Token, TokenisedFileData};"],
      [2, ""],
      [3, "pub struct Parser {"],
      [4, "    files: Vec<TokenisedFileData>,"],
      [5, "}"],
      [6, ""],
      [7, "impl Parser {"],
      [8, "    pub fn new(files: Vec<TokenisedFileData>) -> Parser {"],
      [9, "        Parser {"],
      [10, "            files"],
      [11, "        }"],
      [12, "    }"],
      [13, ""],
      [14, "    pub fn possible_objects(&mut self) {"],
      [15, "        for file in &self.files {"],
      [16, "            for lines in &file.lines {"],
      [17, "                if lines.1.contains(&Token::ObjectDeclaration) {"],
      [18, "                    println!(\"{} {:?} {:?}\", lines.0, lines.1, file.filepath)"],
      [19, "                }"],
      [20, "            }"],
      [21, "        }"],
      [22, "    }"],
      [23, "}"]
    ]
  },
  {
    "fileName": "/Users/jamiebyers/Documents/Code/Projects/ClassTree/src/structs.rs",
    "fileType": "rust",
    "fileNo": 4,
    "lines": [
      [1, "use crate::HashMap;"],
      [2, ""],
      [3, "#[derive(Clone)]"],
      [4, "pub struct FileData {"],
      [5, "    pub file_no: i16,"],
      [6, "    pub file_type: String,"],
      [7, "    pub filepath: String,"],
      [8, "    pub lines: HashMap<i64, String>"],
      [9, "}"],
      [10, ""],
      [11, "#[derive(Debug)]"],
      [12, "pub struct TokenisedFileData {"],
      [13, "    pub file_no: i16,"],
      [14, "    pub file_type: String,"],
      [15, "    pub filepath: String,"],
      [16, "    pub lines: HashMap<i64, Vec<Token>>"],
      [17, ""],
      [18, "}"],
      [19, ""],
      [20, "#[derive(Debug, PartialEq)]"],
      [21, "pub enum Token {"],
      [22, "    ObjectDeclaration,"],
      [23, "    Identifier(String),"],
      [24, "    StringLiteral(String),"],
      [25, "    Number(String),"],
      [26, "    BlockOpen(char),"],
      [27, "    BlockClose,"],
      [28, "    Comma,"],
      [29, "    Semicolon,"],
      [30, "    Parenthesis(char),"],
      [31, "    Equals,"],
      [32, "    Other(char),"],
      [33, "    Eof,"],
      [34, "}"]
    ]
  },
  {
    "fileName": "/Users/jamiebyers/Documents/Code/Projects/ClassTree/src/test_py.py",
    "fileType": "python",
    "fileNo": 5,
    "lines": [
      [1, "class Parent:"],
      [2, "    def __init__(self) -> None:"],
      [3, "        self.parent = None"],
      [4, ""],
      [5, "class Pchild(Parent):"],
      [6, "    def __init__(self) -> None:"],
      [7, "        super().__init__()"],
      [8, ""],
      [9, "class Child:"],
      [10, "    def __init__(self) -> None:"],
      [11, "        super().__init__()"]
    ]
  },
  {
    "fileName": "/Users/jamiebyers/Documents/Code/Projects/ClassTree/target/debug/build/serde-b2d0dc64bda0a6f1/out/private.rs",
    "fileType": "rust",
    "fileNo": 6,
    "lines": [
      [1, "#[doc(hidden)]"],
      [2, "pub mod __private228 {"],
      [3, "    #[doc(hidden)]"],
      [4, "    pub use crate::private::*;"],
      [5, "}"],
      [6, "use serde_core::__private228 as serde_core_private;"]
    ]
  },
  {
    "fileName": "/Users/jamiebyers/Documents/Code/Projects/ClassTree/target/debug/build/serde_core-e2f3a52795243a1c/out/private.rs",
    "fileType": "rust",
    "fileNo": 7,
    "lines": [
      [1, "#[doc(hidden)]"],
      [2, "pub mod __private228 {"],
      [3, "    #[doc(hidden)]"],
      [4, "    pub use crate::private::*;"],
      [5, "}"]
    ]
  }
]
